#!/usr/bin/env python3
import sys
import subprocess
import os
import time
from notify import notification

sys.path.append(os.path.expanduser("~/.dotfiles/python/modules"))
import dotfiles

# Check if wf-recorder is already running
if subprocess.run(["pgrep", "-x", "wf-recorder"], capture_output=True).returncode == 0:
    # Stop recording
    subprocess.run(["killall", "-s", "SIGINT", "wf-recorder"])
    notification("sway_recorder", message="Recording stopped", app_name="sway")

    # Wait for wf-recorder to finish
    while (
        subprocess.run(["pgrep", "-x", "wf-recorder"], capture_output=True).returncode
        == 0
    ):
        time.sleep(0.1)

    # Remove lock file
    lock_file = "/tmp/sway_recorder.lock"
    if os.path.exists(lock_file):
        os.remove(lock_file)

    # Signal waybar to update
    subprocess.run(["pkill", "-RTMIN+8", "waybar"])

    # Find the most recent video file
    videos_dir = os.path.expanduser("~/Videos")
    if os.path.exists(videos_dir):
        files = sorted(
            [f for f in os.listdir(videos_dir) if f.endswith(".mp4")],
            key=lambda f: os.path.getmtime(os.path.join(videos_dir, f)),
            reverse=True,
        )
        if files:
            path = os.path.join(videos_dir, files[0])
            extension = files[0].split(".")[-1]
            name = dotfiles.generate_filename(extension)

            # Show menu for what to do with the file
            options = ["push", "keep", "clipboard", "gimp"]
            result = dotfiles.rofi.dmenu(options)

            if result == "push":
                dotfiles.upload_to_server(path, name, "sway_recorder")
            elif result == "keep":
                notification(
                    "sway_recorder", message=f"File kept at {path}", app_name="sway"
                )
            elif result == "clipboard":
                notification(
                    "sway_recorder", message=f"Video file: {path}", app_name="sway"
                )
            elif result == "gimp":
                subprocess.Popen(["gimp", path])
            else:
                # User cancelled or didn't select an option - delete the file
                if os.path.exists(path):
                    os.remove(path)
                    notification(
                        "sway_recorder",
                        message="Recording deleted",
                        app_name="sway",
                    )
    exit(0)

# Start recording - show mode selection
recording_modes = ["full", "area", "window"]
selected_mode = dotfiles.rofi.dmenu(recording_modes)

if selected_mode not in recording_modes:
    exit(0)

# Generate filename
extension = "mp4"
name = dotfiles.generate_filename(extension)

videos_dir = os.path.expanduser("~/Videos")
os.makedirs(videos_dir, exist_ok=True)
path = os.path.join(videos_dir, name)

# Get geometry based on mode
try:
    selection = dotfiles.get_sway_selection(selected_mode)
except dotfiles.SwaySelectionError as e:
    notification("sway_recorder", message=str(e), app_name="sway")
    exit(1)

wf_recorder_cmd = [
    "wf-recorder",
    "-r",
    "60",  # Frame rate: 60 fps
    "-c",
    "h264_vaapi",  # Codec: hardware-accelerated H.264 via VAAPI (auto-detects GPU)
    "-p",
    "qp=18",  # Quality parameter: lower = higher quality (18 is near-lossless)
    "-p",
    "color_primaries=bt709",  # Color space: BT.709 (standard for HD video)
    "-p",
    "color_trc=bt709",  # Transfer characteristics: BT.709
    "-p",
    "colorspace=bt709",  # Color matrix: BT.709
]

if selection["type"] == "area":
    wf_recorder_cmd.extend(["-g", selection["geometry"], "-f", path])
elif selection["type"] == "full":
    wf_recorder_cmd.extend(["-o", selection["output_name"], "-f", path])
elif selection["type"] == "window":
    wf_recorder_cmd.extend(["-g", selection["geometry"], "-f", path])

# Start recording
recording_process = subprocess.Popen(
    wf_recorder_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
)

# Save start timestamp to lock file for timer
lock_file = "/tmp/sway_recorder.lock"
script_pid = os.getpid()
start_timestamp = time.time()
with open(lock_file, "w") as f:
    f.write(f"{recording_process.pid}\n{script_pid}\n{path}\n{start_timestamp}")

notification(
    "sway_recorder",
    message=f"Recording started ({selected_mode} mode)",
    app_name="sway",
)

# Signal waybar to update
subprocess.run(["pkill", "-RTMIN+8", "waybar"])
